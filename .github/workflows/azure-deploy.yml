name: Azure Functions Python CI/CD Avanzado

on:
  push:
    branches:
      - main # Despliega en cada push a main
  pull_request:
    branches:
      - main # Ejecuta chequeos (lint, test) en cada PR a main

jobs:
  build_and_test:
    runs-on: ubuntu-latest
    outputs:
      # Necesario si se separa el despliegue en otro job dependiente
      # package_path: ${{ steps.create_package.outputs.package_path }} 
      needs_deployment: ${{ steps.check_branch.outputs.needs_deployment }} # Indica si es un push a main

    steps:
    - name: Checkout del código
      uses: actions/checkout@v4 # Usar v4

    - name: Configurar Python 3.11
      uses: actions/setup-python@v5 # Usar v5
      with:
        python-version: '3.11'

    # --- Caché de Dependencias ---
    - name: Cache de dependencias Pip
      uses: actions/cache@v4 # Usar v4
      with:
        path: ~/.cache/pip # Ruta estándar de caché de pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements*.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    # --- Instalación de Dependencias ---
    - name: Instalar dependencias y herramientas de desarrollo
      run: |
        python -m venv .venv         # Crear entorno virtual
        source .venv/bin/activate    # Activar entorno virtual (sintaxis bash)
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        # Si tienes dependencias de desarrollo separadas:
        # pip install -r requirements-dev.txt 
        pip install flake8 pytest # Asegúrate que estén aquí o en requirements*.txt

    # --- Calidad y Pruebas ---
    - name: Linting con Flake8
      run: |
        source .venv/bin/activate
        # Detiene el flujo si hay errores (--count), muestra el fuente (--show-source),
        # y estadísticas (--statistics). Excluye el entorno virtual.
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics --exclude=.venv,__pycache__
        # Puedes ajustar las reglas de Flake8 o añadir más linters como Black, isort aquí

    - name: Ejecutar Pruebas con Pytest
      run: |
        source .venv/bin/activate
        pytest # Asegúrate que tus pruebas estén configuradas para ser descubiertas por pytest

    # --- Crear Paquete de Despliegue ---
    - name: Instalar dependencias en carpeta de despliegue
      id: install_deps # Asigna un ID para referenciar la salida
      run: |
        source .venv/bin/activate
        # Crea la estructura de carpetas que Azure Functions espera para Python
        pip install --target="./.python_packages/lib/site-packages" -r requirements.txt

    - name: Crear archivo Zip para despliegue
      id: create_package
      run: |
        # Empaqueta el código de la función y las dependencias instaladas
        # Asegúrate de incluir todos los archivos necesarios (ej. __init__.py, function.json, host.json, etc.)
        # Excluye archivos/carpetas innecesarios (.git, .venv, tests, etc.)
        zip --quiet -r deployment_package.zip . -x ".venv/*" ".git/*" ".github/*" "tests/*" "*.pyc" "*__pycache__*" ".pytest_cache/*" "local.settings.json" ".vscode/*" "readme.md" ".gitignore"
        # Mueve el paquete a una ubicación conocida o usa directamente deployment_package.zip
        echo "package_path=deployment_package.zip" >> $GITHUB_OUTPUT
        
    # --- Subir Artefacto (Opcional pero recomendado) ---
    - name: Subir artefacto de despliegue
      uses: actions/upload-artifact@v4
      with:
        name: python-functionapp-package
        path: deployment_package.zip

    # --- Verificar si es necesario desplegar (solo en push a main) ---
    - name: Determinar si se debe desplegar
      id: check_branch
      run: |
        if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/main" ]]; then
          echo "needs_deployment=true" >> $GITHUB_OUTPUT
        else
          echo "needs_deployment=false" >> $GITHUB_OUTPUT
        fi


  # --- Job de Despliegue (depende del job anterior) ---
  deploy:
    runs-on: ubuntu-latest
    needs: build_and_test # Depende del éxito del job anterior
    # Solo ejecuta este job si needs_deployment es true (push a main)
    if: needs.build_and_test.outputs.needs_deployment == 'true'

    environment: 
      # Opcional: Define un entorno en GitHub (ej. 'production') para reglas/secretos específicos
      name: production 
      url: ${{ steps.deploy_to_azure.outputs.webapp-url }} # URL de la app desplegada

    steps:
    - name: Checkout del código (necesario si no se usa artefacto)
      # Si usas artefacto, este checkout no es estrictamente necesario, pero no hace daño
      uses: actions/checkout@v4 

    # --- Descargar Artefacto (si se subió en el job anterior) ---
    - name: Descargar artefacto de despliegue
      uses: actions/download-artifact@v4
      with:
        name: python-functionapp-package
        # path: . # Descarga al directorio raíz (o especifica otro)

    # --- Desplegar a Azure Functions ---
    - name: Desplegar a Azure Functions
      id: deploy_to_azure
      uses: Azure/functions-action@v1
      with:
        app-name: EliteDynamicsFuncions # Nombre de tu Function App en Azure
        package: deployment_package.zip # Despliega el paquete .zip creado
        # ¡IMPORTANTE! Debes configurar un secreto en GitHub llamado 'AZURE_FUNCTIONS_PUBLISH_PROFILE_EliteDynamicsFuncions'
        # con el contenido del perfil de publicación descargado desde Azure Portal.
        # El nombre exacto del secreto puede variar, consulta la documentación de Azure/functions-action si tienes problemas.
        publish-profile: ${{ secrets.AZURE_FUNCTIONS_PUBLISH_PROFILE_EliteDynamicsFuncions }}
